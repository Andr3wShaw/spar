#!/usr/bin/env python2

import sys
from math import *

import rospy
import actionlib
from actionlib_msgs.msg import GoalStatus

from geometry_msgs.msg import Point, PoseStamped

from spar_msgs.msg import FlightMotionAction, FlightMotionGoal


# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class Guidance():
	def __init__(self, waypoints):
		# Make sure we have a valid waypoint list
		if not self.check_waypoints(waypoints):
			raise ArgumentError("Invalid waypoint input!")

		# Internal counter to see what waypoint were are up to
		self.waypoint_counter = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False

		# Save the input waypoints
		self.waypoints = waypoints

		# Make some space to record down our current location
		self.current_location = Point()
		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear", 0.2)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)

		# Create our action client
		action_ns = rospy.get_param("~action_topic", 'spar/flight')
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission")

			# Setup first waypoint segment
			# XXX: Another option would be to do "takeoff"
			self.send_wp(self.waypoints[0])
			self.waypoint_counter += 1

			# Setup a timer to check if our waypoint has completed at 20Hz
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			self.sub_pose = rospy.Subscriber("~pose", PoseStamped, self.callback_pose)
			# Subscriber to catch "ROI" diversion commands
			self.sub_roi = rospy.Subscriber("~roi", PoseStamped, self.callback_inspect_roi)

			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)

			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.on_shutdown( lambda : self.shutdown() )


	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):
		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(wps):
			# Make sure each waypoint is a list
			if not isinstance(wps[i], list):
				rospy.logwarn("Waypoint %i is not a list of coordinates" % (i + 1))
				return False

			# Make sure each waypoint has 4 values
			if len(wps) != 4:
				rospy.logwarn("Waypoint %i has an invalid length (must be X/Y/Z/Yaw)" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	def shutdown(self):
		# Unregister anything that needs it here
		self.sub_pose.unregister()
		self.sub_roi.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("Guidance stopped!")


	def callback_pose(self, msg_in):
		# Store the current position at all times so it can be accessed later
		self.current_location = msg_in.pose.position

	# Callback to handle an alert to inspect a ROI
	def callback_inspect_roi(self, msg_in):
		# TODO: HERE!
		pass

		# rospy.loginfo("[NAV] Got imagery trigger!")
		# rospy.loginfo("[NAV] Stopping for 5 seconds")

		# self.client_base.cancel_goal()
		# rospy.sleep(rospy.Duration(5.0))

		# rospy.loginfo("[NAV] Continuing to end point...")

		# self.send_wp_path(self.current_pos, self.yaw_start, self.p_end, self.yaw_end, self.nom_lvel)

	def send_wp(self):


	# We recieve a timer event (te) from rospy.Timer()
	def check_waypoint_status(self, te):
		# If the last segment has succeeded.
		# For more complex tasks, it might be necessary to also
		# check if you are in waypoint or diversion mode here.
		# Hint: you would ignore a succeeded if in diversion mode.
		# Hint: really, we should check for other status states
		#		(such as aborted), as there are some states
		#		where we won't recover from, and should just exit
		if self.client_base.get_state() == GoalStatus.SUCCEEDED:
			if self.waypoint_counter < (len(self.waypoints)-1):
				self.send_wp(self.waypoints[waypoint_counter])
				# Increment our waypoint counter
				self.waypoint_counter += 1
			else:
				# Else the mission is over, shutdown and quit the node
				rospy.loginfo("Mission complete!")
				rospy.signal_shutdown("complete")

def send_wp(spar_client, x, y, z, yaw):
	speed = rospy.get_param("~speed", 1.0)
	accuracy = rospy.get_param("~accuracy", 0.1)

	goal = FlightMotionGoal()
	goal.motion = FlightMotionGoal.MOTION_GOTO
	goal.position.x = x
	goal.position.y = y
	goal.position.z = z
	goal.yaw = yaw
	goal.velocity_vertical = speed
	goal.velocity_horizontal = speed
	goal.yawrate = speed
	goal.wait_for_convergence = True							# Wait for our takeoff "waypoint" to be reached
	goal.position_radius = accuracy
	goal.yaw_range = accuracy

	spar_client.send_goal(goal)
	 # If shutdown is issued, cancel current mission before rospy is shutdown
	rospy.on_shutdown(lambda : spar_client.cancel_goal())
	# Wait for the result of the goal
	spar_client.wait_for_result()

	#Stop at waypoint for a moment
	rospy.sleep(2)

	# Output some feedback for our motion
	return spar_client.get_state() == GoalStatus.SUCCEEDED

def send_wps(spar_client):
	success = True

	# List of waypoints
	# [X, Y, Z, Yaw]
	wps = [[ 0.0, 0.0, 1.0, 0.0],
		   [ 1.0, 1.0, 1.0, 0.0],
		   [-1.0, 1.0, 1.0, 0.0],
		   [-1.0,-1.0, 1.0, 0.0],
		   [ 1.0,-1.0, 1.0, 0.0],
		   [ 0.0, 0.0, 1.0, 0.0]]

	# Loop through each waypoint in our list
	i = 0
	for wp in wps:
		rospy.loginfo("Sending waypoint %i..." % (i + 1))
		success = send_wp(spar_client, wp[0], wp[1], wp[2], wp[3])
		i += 1

		# If we had an error, print and stop sending
		if not success:
			rospy.logerr("Waypoints failed!")
			break;

	if success:
		rospy.loginfo("Waypoints complete!")

def main(args):
	# Initialise ROS
	rospy.init_node('guidance', anonymous=True)

	guide = guidance

	# Send the flight command
	# This will lock the thread until it is "done"
	# Make sure "ros is ok" in case we hit CTRL-C while waiting above
	if not rospy.is_shutdown():
		send_wps(spar_client)

if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('')
